[[search-template]]
== 搜索模板

`/_search/template` 端点允许使用 mustache 语言来预先渲染搜索请求，
在它们被执行之前将会使用模板参数来对该模板进行填充。

[source,js]
------------------------------------------
GET _search/template
{
    "source" : {
      "query": { "match" : { "{{my_field}}" : "{{my_value}}" } },
      "size" : "{{my_size}}"
    },
    "params" : {
        "my_field" : "message",
        "my_value" : "some message",
        "my_size" : 5
    }
}
------------------------------------------
// CONSOLE
// TEST[setup:twitter]

更多关于 Mustache 模板的信息以及可以用它做怎样的模板化请参阅
http://mustache.github.io/mustache.5.html[mustache 项目的在线文档] 。

NOTE: Mustache 作为脚本语言在 Elasticsearch 沙箱中执行，
因此它受到用来启用或禁用索引类型和会话中脚本的开关控制，其在以下
<<allowed-script-types-setting, 脚本文档>> 中描述

[float]
==== 更多模板的例子

[float]
===== 用单个值来填充查询字符串

[source,js]
------------------------------------------
GET _search/template
{
    "source": {
        "query": {
            "term": {
                "message": "{{query_string}}"
            }
        }
    },
    "params": {
        "query_string": "search for these words"
    }
}
------------------------------------------
// CONSOLE
// TEST[setup:twitter]

[float]
===== 将参数转化为 JSON

函数 `{{#toJson}}parameter{{/toJson}}` 可以用来把参数例如字典和数组转化成它们的 JSON 表现形式：

[source,js]
------------------------------------------
GET _search/template
{
  "source": "{ \"query\": { \"terms\": {{#toJson}}statuses{{/toJson}} }}",
  "params": {
    "statuses" : {
        "status": [ "pending", "published" ]
    }
  }
}
------------------------------------------
// CONSOLE

将被渲染为：

[source,js]
------------------------------------------
{
  "query": {
    "terms": {
      "status": [
        "pending",
        "published"
      ]
    }
  }
}
------------------------------------------
// NOTCONSOLE

下面这个例子略微复杂，替换一个包含 JSON 对象的数组：

[source,js]
------------------------------------------
GET _search/template
{
    "source": "{\"query\":{\"bool\":{\"must\": {{#toJson}}clauses{{/toJson}} }}}",
    "params": {
        "clauses": [
            { "term": { "user" : "foo" } },
            { "term": { "user" : "bar" } }
        ]
   }
}
------------------------------------------
// CONSOLE

将被渲染为：

[source,js]
------------------------------------------
{
    "query" : {
      "bool" : {
        "must" : [
          {
            "term" : {
                "user" : "foo"
            }
          },
          {
            "term" : {
                "user" : "bar"
            }
          }
        ]
      }
    }
}
------------------------------------------
// NOTCONSOLE

[float]
===== Concatenating array of values

函数 `{{#join}}array{{/join}}` 可以用来将数组中的值拼接为一个逗号分割的字符串：

[source,js]
------------------------------------------
GET _search/template
{
  "source": {
    "query": {
      "match": {
        "emails": "{{#join}}emails{{/join}}"
      }
    }
  },
  "params": {
    "emails": [ "username@email.com", "lastname@email.com" ]
  }
}
------------------------------------------
// CONSOLE

将被渲染为：

[source,js]
------------------------------------------
{
    "query" : {
        "match" : {
            "emails" : "username@email.com,lastname@email.com"
        }
    }
}
------------------------------------------
// NOTCONSOLE

该函数也接受自定义的分割符：

[source,js]
------------------------------------------
GET _search/template
{
  "source": {
    "query": {
      "range": {
        "born": {
            "gte"   : "{{date.min}}",
            "lte"   : "{{date.max}}",
            "format": "{{#join delimiter='||'}}date.formats{{/join delimiter='||'}}"
	    }
      }
    }
  },
  "params": {
    "date": {
        "min": "2016",
        "max": "31/12/2017",
        "formats": ["dd/MM/yyyy", "yyyy"]
    }
  }
}
------------------------------------------
// CONSOLE

将被渲染为：

[source,js]
------------------------------------------
{
    "query" : {
      "range" : {
        "born" : {
          "gte" : "2016",
          "lte" : "31/12/2017",
          "format" : "dd/MM/yyyy||yyyy"
        }
      }
    }
}

------------------------------------------
// NOTCONSOLE

[float]
===== 默认值

默认值可以写为 `{{var}}{{^var}}default{{/var}}` 例如：

[source,js]
------------------------------------------
{
  "source": {
    "query": {
      "range": {
        "line_no": {
          "gte": "{{start}}",
          "lte": "{{end}}{{^end}}20{{/end}}"
        }
      }
    }
  },
  "params": { ... }
}
------------------------------------------
// NOTCONSOLE

当 `params` 为 `{ "start": 10, "end": 15 }` 时，这个请求将被渲染为：

[source,js]
------------------------------------------
{
    "range": {
        "line_no": {
            "gte": "10",
            "lte": "15"
        }
  }
}
------------------------------------------
// NOTCONSOLE

但是当 `params` 为 `{ "start": 10 }` 时，该请求将使用 `end` 的默认值：

[source,js]
------------------------------------------
{
    "range": {
        "line_no": {
            "gte": "10",
            "lte": "20"
        }
    }
}
------------------------------------------
// NOTCONSOLE

[float]
===== 条件语句

我们不能使用 JSON 形式的模板来表示条件语句，模板 **必须** 以字符串的形式来传递。
举例来说，假使我们想要对 `line` 字段运行一个 `match` 查询，并视需要按行号来做过滤，
在这里 `start` 与 `end` 都是可选的。

`params` 看起来会是这样：
[source,js]
------------------------------------------
{
    "params": {
        "text":      "words to search for",
        "line_no": { <1>
            "start": 10, <1>
            "end":   20  <1>
        }
    }
}
------------------------------------------
// NOTCONSOLE
<1> 这里的三个元素都是可选的。

我们可以将查询写为如下形式：

[source,js]
------------------------------------------
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "line": "{{text}}" <1>
        }
      },
      "filter": {
        {{#line_no}} <2>
          "range": {
            "line_no": {
              {{#start}} <3>
                "gte": "{{start}}" <4>
                {{#end}},{{/end}} <5>
              {{/start}} <3>
              {{#end}} <6>
                "lte": "{{end}}" <7>
              {{/end}} <6>
            }
          }
        {{/line_no}} <2>
      }
    }
  }
}
------------------------------------------
// NOTCONSOLE
<1> 以参数 `text` 的值进行填充
<2> 仅当指定了 `line_no` 时，包含 `range` 过滤器
<3> 仅当指定了 `line_no.start` 时，包含 `gte` 语句
<4> 以参数 `line_no.start` 的值进行填充
<5> 仅当指定了 `line_no.start` 与 `line_no.end` 时，在 `gte` 语句后面添加一个逗号
<6> 仅当指定了 `line_no.end` 时，包含 `lte` 语句
<7> 以参数 `line_no.end` 的值进行填充

[NOTE]
==================================
如上所述，这个模板并不是一个合法的 JSON因为它包含了像 `{{#line_no}}` 这样的 _段_ 标记。
因此，这样的模板应当被存储在文件中（见 <<pre-registered-templates>>），
或者当使用 REST API 时应当写成字符串的形式：

[source,js]
--------------------
"source": "{\"query\":{\"bool\":{\"must\":{\"match\":{\"line\":\"{{text}}\"}},\"filter\":{{{#line_no}}\"range\":{\"line_no\":{{{#start}}\"gte\":\"{{start}}\"{{#end}},{{/end}}{{/start}}{{#end}}\"lte\":\"{{end}}\"{{/end}}}}{{/line_no}}}}}}"
--------------------
// NOTCONSOLE
==================================


[float]
===== URL 编码

`{{#url}}value{{/url}}` 可以用来将字符串的值编码为 HTML 编码的形式，具体定义请参考 http://www.w3.org/TR/html4/[HTML 规范]。

在以下例子中，可以很方便地编码一个 URL：

[source,js]
------------------------------------------
GET _render/template
{
    "source" : {
        "query" : {
            "term": {
                "http_access_log": "{{#url}}{{host}}/{{page}}{{/url}}"
            }
        }
    },
    "params": {
        "host": "https://www.elastic.co/",
        "page": "learn"
    }
}
------------------------------------------
// CONSOLE

上面的查询将会被渲染为：

[source,js]
------------------------------------------
{
    "template_output" : {
        "query" : {
            "term" : {
                "http_access_log" : "https%3A%2F%2Fwww.elastic.co%2F%2Flearn"
            }
        }
    }
}
------------------------------------------
// TESTRESPONSE


[float]
[[pre-registered-templates]]
===== 预注册模板

你可以使用存储脚本 API 来注册搜索模板。

[source,js]
------------------------------------------
POST _scripts/<templatename>
{
    "script": {
        "lang": "mustache",
        "source": {
            "query": {
                "match": {
                    "title": "{{query_string}}"
                }
            }
        }
    }
}
------------------------------------------
// CONSOLE
// TEST[continued]

//////////////////////////

我们想要确认模板已经被添加，因为稍后我们会使用它。

[source,js]
--------------------------------------------------
{
    "acknowledged" : true
}
--------------------------------------------------
// TESTRESPONSE

//////////////////////////

该模板可以通过以下方式来获取

[source,js]
------------------------------------------
GET _scripts/<templatename>
------------------------------------------
// CONSOLE
// TEST[continued]

将会渲染为：

[source,js]
------------------------------------------
{
    "script" : {
        "lang" : "mustache",
        "source" : "{\"query\":{\"match\":{\"title\":\"{{query_string}}\"}}}",
        "options": {
          "content_type" : "application/json; charset=UTF-8"
        }
    },
    "_id": "<templatename>",
    "found": true
}
------------------------------------------
// TESTRESPONSE

该模板可以通过以下方式来删除

[source,js]
------------------------------------------
DELETE _scripts/<templatename>
------------------------------------------
// CONSOLE
// TEST[continued]

//////////////////////////

我们想要确认模板已经被添加，因为稍后我们会使用它。

[source,js]
--------------------------------------------------
{
    "acknowledged" : true
}
--------------------------------------------------
// TESTRESPONSE

//////////////////////////

若想要在搜索时使用一个已经贮存的模板：

[source,js]
------------------------------------------
GET _search/template
{
    "id": "<templateName>", <1>
    "params": {
        "query_string": "search for these words"
    }
}
------------------------------------------
// CONSOLE
// TEST[catch:missing]
<1> 已经贮存的模板脚本名。

[float]
==== 验证模板

一个模板可以在响应中通过指定的参数来渲染

[source,js]
------------------------------------------
GET _render/template
{
  "source": "{ \"query\": { \"terms\": {{#toJson}}statuses{{/toJson}} }}",
  "params": {
    "statuses" : {
        "status": [ "pending", "published" ]
    }
  }
}
------------------------------------------
// CONSOLE

该调用将返回渲染后的模板：

[source,js]
------------------------------------------
{
  "template_output": {
    "query": {
      "terms": {
        "status": [ <1>
          "pending",
          "published"
        ]
      }
    }
  }
}
------------------------------------------
// TESTRESPONSE
<1> `status` 数组已经借由 `params` 对象的值来修改。

预注册模板同样可以按以下方式渲染：

[source,js]
------------------------------------------
GET _render/template/<template_name>
{
  "params": {
    "..."
  }
}
------------------------------------------
// NOTCONSOLE

[float]
===== Explain

在运行一个模板的时候你可以指定 `explain` 参数：

[source,js]
------------------------------------------
GET _search/template
{
  "id": "my_template",
  "params": {
    "status": [ "pending", "published" ]
  },
  "explain": true
}
------------------------------------------
// CONSOLE
// TEST[catch:missing]

[float]
===== Profiling

在运行一个模板的时候你可以指定 `profile` 参数：

[source,js]
------------------------------------------
GET _search/template
{
  "id": "my_template",
  "params": {
    "status": [ "pending", "published" ]
  },
  "profile": true
}
------------------------------------------
// CONSOLE
// TEST[catch:missing]

[[multi-search-template]]
== 多模板搜索

多模板搜索 API 允许通过 `_msearch/template` 端点使用相同的 API 执行若干个模板搜索请求。

请求的格式类似于 <<search-multi-search, 多搜索 API>> 的格式：

[source,js]
--------------------------------------------------
header\n
body\n
header\n
body\n
--------------------------------------------------
// NOTCONSOLE

header 部分与通常的多搜索 API 一样支持 `index` 、 `search_type` 、
`preference` 以及 `routing` 选项。

body 部分包含一个模板搜索体，支持内联（Inline）、预存储以及文件模板。
如以下：

[source,js]
--------------------------------------------------
$ cat requests
{"index": "test"}
{"source": {"query": {"match":  {"user" : "{{username}}" }}}, "params": {"username": "john"}} <1>
{"source": {"query": {"{{query_type}}": {"name": "{{name}}" }}}, "params": {"query_type": "match_phrase_prefix", "name": "Smith"}}
{"index": "_all"}
{"id": "template_1", "params": {"query_string": "search for these words" }} <2>

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo
--------------------------------------------------
// NOTCONSOLE
// 未转换为 console 的形式，因为我们想要用 curl 来展示如何是工作的
<1> 内联模板搜索请求

<2> 模板搜索请求基于一个已贮存的模板

响应中包含一个 `responses` 数组，其中包含了每个模板搜索请求的响应，顺序按照原始多模板搜索请求中的顺序。
若其中的某个模板搜索完全失败，其对应的响应会替换为包含 `error` 消息的对象。
