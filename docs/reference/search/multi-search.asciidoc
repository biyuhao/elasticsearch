[[search-multi-search]]
== 多搜索 API

多搜索 API 允许你在相同的 API 中执行多个搜索请求。端点为 `_msearch` 。

请求格式和 bulk API 格式相似，使用以换行符分割的 JSON（NDJSON）格式。结构如下所示（该结构经过特别的优化以降低解析代价当一个特定的搜索结束无需转发至另一个节点）：

[source,js]
--------------------------------------------------
header\n
body\n
header\n
body\n
--------------------------------------------------
// NOTCONSOLE

*NOTE*: 数据的最后一行必须以一个换行符 `\n` 来结束。每个换行符前允许添加一个 `\r` 。当向该端点发送请求时应当将 `Content-Type` header 设置为 `application/x-ndjson` 。

header 部分包含了当前请求应该应用于哪个或者哪些索引的信息，以及 `search_type` 、 `preference` 和 `routing` 。body 部分包含了通常搜索请求的 body（包含 `query` 、 `aggregations` 、 `from` 、 `size` 等）下面是一个例子：

[source,js]
--------------------------------------------------
$ cat requests
{"index" : "test"}
{"query" : {"match_all" : {}}, "from" : 0, "size" : 10}
{"index" : "test", "search_type" : "dfs_query_then_fetch"}
{"query" : {"match_all" : {}}}
{}
{"query" : {"match_all" : {}}}

{"query" : {"match_all" : {}}}
{"search_type" : "dfs_query_then_fetch"}
{"query" : {"match_all" : {}}}
--------------------------------------------------
// NOTCONSOLE

[source,js]
--------------------------------------------------
$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch --data-binary "@requests"; echo
--------------------------------------------------
// NOTCONSOLE

注意，上面的例子中，header 为空（也可以没有任何内容）同样也是支持的。

响应部分返回了一个 `responses` 数组，包含了按照原始多搜索请求顺序的对应响应以及状态码。如若某个搜索请求完全失败，会有一个包含 `error` 信息以及对应状态码的对象来取代实际的搜索响应。

[source,js]
--------------------------------------------------
GET twitter/_msearch
{}
{"query" : {"match_all" : {}}, "from" : 0, "size" : 10}
{}
{"query" : {"match_all" : {}}}
{"index" : "twitter2"}
{"query" : {"match_all" : {}}}
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

以上中所有未指定具体索引的搜索请求都会针对 `twitter` 索引执行，最后一个则针对 `twitter2` 索引。

`search_type` 可以用类似的方式设置为全局的以应用于所有搜索请求。

多搜索的 `max_concurrent_searches` 请求参数可以用来控制多搜索 api 的最大并发请求数。默认值基于 data 节点数量以及默认的 搜索线程池大小。

请求参数 `max_concurrent_shard_requests` 可以用来控制每个搜索请求的最大分片并发请求数。该值应当用于保护集群避免被单个请求过载（默认请求会命中集群中的所有索引，当每个节点中分片数量过多时可能会导致分片请求被拒绝）默认值基于集群中 data 节点数量但最大为 `256` 。在某些特定场景并非通过并发请求来达到并行，这样该保护措施可能会导致性能降低。例如在某个环境中只会有很少的并发请求，将该值适当提高可能会有所帮助。

[float]
[[msearch-security]]
=== 安全性

详见 <<url-access-control>>

[float]
[[template-msearch]]
=== 模板支持

很像 <<search-template>> 中描述的 _search 资源那样， _msearch 同样支持模板。请像如下那样提交请求：

[source,js]
-----------------------------------------------
GET _msearch/template
{"index" : "twitter"}
{ "source" : "{ \"query\": { \"match\": { \"message\" : \"{{keywords}}\" } } } }", "params": { "query_type": "match", "keywords": "some message" } }
{"index" : "twitter"}
{ "source" : "{ \"query\": { \"match_{{template}}\": {} } }", "params": { "template": "all" } }
-----------------------------------------------
// CONSOLE
// TEST[setup:twitter]

来使用内联模板。

你还可以这样创建搜索模板：

[source,js]
------------------------------------------
POST /_scripts/my_template_1
{
    "script": {
        "lang": "mustache",
        "source": {
            "query": {
                "match": {
                    "message": "{{query_string}}"
                }
            }
        }
    }
}
------------------------------------------
// CONSOLE
// TEST[setup:twitter]

[source,js]
------------------------------------------
POST /_scripts/my_template_2
{
    "script": {
        "lang": "mustache",
        "source": {
            "query": {
                "term": {
                    "{{field}}": "{{value}}"
                }
            }
        }
    }
}
------------------------------------------
// CONSOLE
// TEST[continued]

然后稍后在 _msearch 中使用它们：

[source,js]
-----------------------------------------------
GET _msearch/template
{"index" : "main"}
{ "id": "my_template_1", "params": { "query_string": "some message" } }
{"index" : "main"}
{ "id": "my_template_2", "params": { "field": "user", "value": "test" } }
-----------------------------------------------
// CONSOLE
// TEST[continued]
